"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require("@angular/core");
var Paginator = (function () {
    function Paginator() {
        // -------------------------------------------------------------------------
        // Inputs / Outputs
        // -------------------------------------------------------------------------
        this.currentPage = 1;
        this.hideOnSinglePage = true;
        this.boundaryLinks = false;
        this.directionLinks = true;
        this.boundaryFirstLabel = "First";
        this.boundaryLastLabel = "Last";
        this.directionNextLabel = "»";
        this.directionPreviousLabel = "«";
        this.onChange = new core_1.EventEmitter();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    Paginator.prototype.changePage = function (page) {
        if (page < 1 || page > this.getTotalPagesCount())
            return;
        this.currentPage = page;
        this.onChange.emit(page);
    };
    Paginator.prototype.getPages = function () {
        var pages = [];
        var startFrom = 1;
        var totalPagesCount = this.getTotalPagesCount();
        var endWith = totalPagesCount;
        if (this.maxVisible) {
            startFrom = Math.max(this.currentPage - Math.floor(this.maxVisible / 2), 1);
            endWith = startFrom + this.maxVisible - 1;
            if (endWith > totalPagesCount) {
                endWith = totalPagesCount;
                startFrom = endWith - this.maxVisible + 1;
            }
            if (startFrom < 1)
                startFrom = 1;
        }
        for (var i = startFrom; i <= endWith; i++) {
            pages.push(i);
        }
        return pages;
    };
    Paginator.prototype.getTotalPagesCount = function () {
        return Math.ceil(this.total / this.onPage);
    };
    return Paginator;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Paginator.prototype, "total", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Paginator.prototype, "onPage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Paginator.prototype, "currentPage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Paginator.prototype, "maxVisible", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Paginator.prototype, "hideOnSinglePage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Paginator.prototype, "boundaryLinks", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Paginator.prototype, "directionLinks", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Paginator.prototype, "boundaryFirstLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Paginator.prototype, "boundaryLastLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Paginator.prototype, "directionNextLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Paginator.prototype, "directionPreviousLabel", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", Object)
], Paginator.prototype, "onChange", void 0);
Paginator = __decorate([
    core_1.Component({
        selector: "paginator",
        template: "\n<nav class=\"paginator\" [class.hidden]=\"hideOnSinglePage && getPages().length <= 1\">\n    <ul class=\"pagination\">\n        <li [ngClass]=\"{ hidden: !boundaryLinks, disabled: currentPage === 1 }\">\n            <a (click)=\"changePage(1)\" [attr.aria-label]=\"boundaryFirstLabel\">{{ boundaryFirstLabel }}</a>\n        </li>\n        <li [ngClass]=\"{ hidden: !directionLinks, disabled: currentPage === 1 }\">\n            <a (click)=\"changePage(currentPage - 1)\" aria-label=\"Previous\">\n                <span aria-hidden=\"true\">{{ directionPreviousLabel }}</span>\n            </a>\n        </li>\n        <li *ngFor=\"let page of getPages()\" [ngClass]=\"{ active: currentPage === page }\">\n            <a (click)=\"changePage(page)\">{{ page }}</a>\n        </li>\n        <li [ngClass]=\"{ hidden: !directionLinks, disabled: currentPage === getTotalPagesCount() }\">\n            <a (click)=\"changePage(currentPage + 1)\" aria-label=\"Next\">\n                <span aria-hidden=\"true\">{{ directionNextLabel }}</span>\n            </a>\n        </li>\n        <li [ngClass]=\"{ hidden: !boundaryLinks, disabled: currentPage === getTotalPagesCount() }\">\n            <a (click)=\"changePage(getTotalPagesCount())\" [attr.aria-label]=\"boundaryLastLabel\">{{ boundaryLastLabel }}</a>\n        </li>\n    </ul>\n</nav>\n", styles: ["\nnav.paginator ul.pagination li {\n    cursor: pointer;\n   -moz-user-select: none;\n   -khtml-user-select: none;\n   -webkit-user-select: none;\n   -ms-user-select: none;\n   user-select: none;\n}\nnav.paginator ul.pagination .hidden {\n    display: none;\n}\n"]
    })
], Paginator);
exports.Paginator = Paginator;
//# sourceMappingURL=Paginator.js.map